# 地球绘制

---

我们将使用算法**生成球体的顶点,纹理**、**光照的基础知识**、**添加光照效果**  
1. **生成球体顶点**  
    ![球体顶点算法示意图](/assets/OpenGL ES入门/地球绘制/球体顶点算法示意图.png)![球体顶点算法1](/assets/OpenGL ES入门/地球绘制/球体顶点算法1.png)![球体顶点算法2](/assets/OpenGL ES入门/地球绘制/球体顶点算法2.png)  

    由第一张图我们可以看出：一个球体可以由下到上切割成N份，组成球体。每一份的绘制由N个连续的三角形绘制成-GL\_TRIANGLE\_STRIP。  
    由第二张图我们可以算出：球体上一个顶点在Y轴的坐标，R\_sin\(a\)。切面圆的半径=此时X轴坐标，hR=R\_cos\(a\)。  
    由第三张图我们可以算出：球体上顶点在Z轴和X轴的坐标，Z轴上的坐标=hR\_sin\(b\)。X轴上的坐标=hR\_cos\(b\)。  
    代码实现：

```
    @Override
    protected void initVert() {
        ArrayList<Float> vertList = new ArrayList<>();

        for (int vAngle = -90; vAngle < 90; vAngle += mVStep) {

            double hR1 = mR * Math.cos(Math.toRadians(vAngle));
            double y1 = mR * Math.sin(Math.toRadians(vAngle));

            double hR2 = mR * Math.cos(Math.toRadians(vAngle + mVStep));
            double y2 = mR * Math.sin(Math.toRadians(vAngle + mVStep));

            for (int hAngle = 0; hAngle <= 360; hAngle += mHStep) {
                double x1 = hR1 * Math.cos(Math.toRadians(hAngle));
                double z1 = hR1 * Math.sin(Math.toRadians(hAngle));

                double x2 = hR2 * Math.cos(Math.toRadians(hAngle));
                double z2 = hR2 * Math.sin(Math.toRadians(hAngle));

                vertList.add((float) x1);
                vertList.add((float) y1);
                vertList.add((float) z1);

                vertList.add((float) x2);
                vertList.add((float) y2);
                vertList.add((float) z2);
            }
        }
        float[] verts = new float[vertList.size()];
        for (int i = 0; i < vertList.size(); i++) {
            verts[i] = vertList.get(i);
        }
        mVertSize = verts.length / 3;
        mVertBuf = ShaderUtils.getFloatBuffer(verts);
    }
```



