# 地球绘制

---

我们将使用算法**生成球体的顶点,纹理坐标**、**光照的基础知识**、**添加光照效果**

* **生成球体顶点**

  ![球体顶点算法示意图](/assets/OpenGL ES入门/地球绘制/球体顶点算法示意图.png)![球体顶点算法1](/assets/OpenGL ES入门/地球绘制/球体顶点算法1.png)![球体顶点算法2](/assets/OpenGL ES入门/地球绘制/球体顶点算法2.png)

  ①由第一张图我们可以看出：一个球体可以由下到上切割成N份，组成球体。每一份的绘制由N个连续的三角形绘制成-GL\_TRIANGLE\_STRIP。

  ②由第二张图我们可以算出：球体上一个顶点在Y轴的坐标，R\_sin\(a\)。切面圆的半径=此时X轴坐标，hR=R\_cos\(a\)。

  ③由第三张图我们可以算出：球体上顶点在Z轴和X轴的坐标，Z轴上的坐标=hR\_sin\(b\)。X轴上的坐标=hR\_cos\(b\)。

  代码实现：

  ```
    @Override
    protected void initVert() {
        ArrayList<Float> vertList = new ArrayList<>();

        for (int vAngle = -90; vAngle < 90; vAngle += mVStep) {

            double hR1 = mR * Math.cos(Math.toRadians(vAngle));
            double y1 = mR * Math.sin(Math.toRadians(vAngle));

            double hR2 = mR * Math.cos(Math.toRadians(vAngle + mVStep));
            double y2 = mR * Math.sin(Math.toRadians(vAngle + mVStep));

            for (int hAngle = 0; hAngle <= 360; hAngle += mHStep) {
                double x1 = hR1 * Math.cos(Math.toRadians(hAngle));
                double z1 = hR1 * Math.sin(Math.toRadians(hAngle));

                double x2 = hR2 * Math.cos(Math.toRadians(hAngle));
                double z2 = hR2 * Math.sin(Math.toRadians(hAngle));

                vertList.add((float) x1);
                vertList.add((float) y1);
                vertList.add((float) z1);

                vertList.add((float) x2);
                vertList.add((float) y2);
                vertList.add((float) z2);
            }
        }
        float[] verts = new float[vertList.size()];
        for (int i = 0; i < vertList.size(); i++) {
            verts[i] = vertList.get(i);
        }
        mVertSize = verts.length / 3;
        mVertBuf = ShaderUtils.getFloatBuffer(verts);
    }
  ```

* **生成纹理坐标**

  ![地球纹理坐标示意图](/assets/OpenGL ES入门/地球绘制/地球纹理坐标示意图.png)

  由图中我们可以看出只要把对应的点转成0.0-1.0，即可完成纹理坐标。公式如下：  
  s=n\_h\_step/360  
  t=n\_v\_step/180

  这样算出的纹理坐标原点为右下角，跟我们纹理坐标的左下角，我们需要再进一步转换：  
  s=1-n\_h\_step/360  
  t=n\_v\_step/180

  注：[立方体绘制](OpenGL ES入门/2. 立方体绘制.md)中，介绍了纹理坐标有可能是左上角，或右上角，需要根据实际情况转换纹理坐标原点。

  代码实现：

  ```
    @Override
    protected void initTextureCoord() {
        ArrayList<Float> texCoordList = new ArrayList<>();
        for (int i = 0; i < 180; i += mVStep) {
            float t1 = 1 - i / 180.0f;
            float t2 = 1 - (i + mVStep) / 180.0f;
            for (int j = 0; j <= 360; j += mHStep) {
                float s = 1 - j / 360.0f;

                texCoordList.add(s);
                texCoordList.add(t1);

                texCoordList.add(s);
                texCoordList.add(t2);
            }
        }
        float[] texCoords = new float[texCoordList.size()];
        for (int i = 0; i < texCoordList.size(); i++) {
            texCoords[i] = texCoordList.get(i);
        }
        mTexCoordBuf = ShaderUtils.getFloatBuffer(texCoords);
    }
  ```

* **光照基础知识**  
    
    一般OpenGL ES中采用phong光照模型。其计算公式为：  
    `surfaceColor = (ambient + diffuse + specular) * objectColor`  
    ①ambient：环境光  
    ②diffuse：漫反射光  
    ③specular：镜面光  
    ![phong光照](/assets/OpenGL ES入门/地球绘制/phong光照.png)

  1. 环境光计算公式：

     `ambient = ambientStrength * lightColor`  
     ①ambientStrength：环境光强度  
     ②lightColor：光颜色

     GLSL代码实现：

     ```
     /**
     * 环境光计算公式
     * @param lightColor 光源颜色
     * @param ambientStrength 环境光强度
     */
     vec4 ambient(vec4 lightColor,float ambientStrength){
         return ambientStrength * lightColor;
     }
     ```

  2. 漫反射光计算公式：

     `diffuse = max(dot(normalize()),0.0)*lightColor`

     如果觉得上面公式比较难记，可以按照下面方法推导。  
     ![漫反射光照](/assets/OpenGL ES入门/地球绘制/漫反射光照.png)  
     简单公式：cos(θ)*lightColor  
     推导：① 当cos(θ)&lt;0时，光源在物体平面的下方，此时光源对物体平面没有任何光照效果。max\(θ,0\);  
     ② 单位化向量的点乘=向量的夹角的余弦值。cos(θ)=dot\(normalize\(-lightDir\),normalize\(N\)\);   
     ③ lightDir=fragPos-lightPos;   
     -lightDir=-fragPos+lightPos;
     -lightDir=lightPos-fragPos;  
     ④ 顶点法向量\(地球是一个球体，所以顶点法向量=顶点向量\)， 一般顶点的法向量是由外部传入的向量。  
     外部法向量算法：



